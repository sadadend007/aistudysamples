<!DOCTYPE html>
<html lang="ko">
<head>
Β  <meta charset="UTF-8">
Β  <title>Encryption λ„κµ¬ (AES + PBKDF2 + RSA)</title>
Β  <style>
Β  Β  body { font-family: Arial; padding: 20px; }
Β  Β  input, button, select { padding: 8px; font-size: 14px; }

Β  Β  nav a { margin-right: 12px; text-decoration: none; color: #0070c9; }
Β  Β  nav a.active { font-weight: bold; text-decoration: underline; }

Β  Β  .row {
Β  Β  Β  display: flex;
Β  Β  Β  align-items: center;
Β  Β  Β  gap: 8px;
Β  Β  Β  margin-bottom: 10px;
Β  Β  }

Β  Β  .row input[type="text"],
Β  Β  .row input[type="number"] {
Β  Β  Β  flex: 1;
Β  Β  Β  padding: 8px;
Β  Β  Β  box-sizing: border-box;
Β  Β  }

Β  Β  .len-box {
Β  Β  Β  width: 180px;
Β  Β  Β  font-size: 12px;
Β  Β  Β  color: #555;
Β  Β  Β  text-align: right;
Β  Β  }

Β  Β  .result-row {
Β  Β  Β  display: flex;
Β  Β  Β  align-items: center;
Β  Β  Β  gap: 8px;
Β  Β  Β  margin-top: 5px;
Β  Β  Β  margin-bottom: 10px;
Β  Β  }

Β  Β  .result-box {
Β  Β  Β  flex: 1;
Β  Β  Β  background: #f7f7f7;
Β  Β  Β  padding: 8px;
Β  Β  Β  border: 1px solid #ccc;
Β  Β  Β  font-size: 14px;
Β  Β  Β  white-space: pre-wrap;
Β  Β  Β  min-height: 38px;
Β  Β  Β  box-sizing: border-box;
Β  Β  Β  display: flex;
Β  Β  Β  align-items: center;
Β  Β  Β  overflow-y: auto;
Β  Β  }

Β  Β  .result-box.key-output {
Β  Β  Β  font-size: 12px; /* RSA ν‚¤ μ¶λ ¥μ€ Base64λ΅ κΈΈμ–΄μ§ μ μμ–΄ κΈ€μ ν¬κΈ° μ΅°μ • */
Β  Β  }

Β  Β  .copy-btn {
Β  Β  Β  padding: 6px 10px;
Β  Β  Β  font-size: 12px;
Β  Β  }

Β  Β  .option-row {
Β  Β  Β  display: flex;
Β  Β  Β  align-items: center;
Β  Β  Β  gap: 16px;
Β  Β  Β  margin-bottom: 8px;
Β  Β  Β  font-size: 14px;
Β  Β  Β  flex-wrap: wrap;
Β  Β  }

Β  Β  small.note { color: #777; }
Β  Β  hr { margin: 20px 0; }
Β  </style>
</head>
<body>

<nav>
Β  <a href="encoding.html">Encoding</a>
Β  <a href="hash.html">Hash</a>
Β  <a href="encryption.html" class="active">Encryption</a>
</nav>
<hr>

<script>
Β  /* ============ κ³µν†µ μ ν‹Έ ============ */

Β  function getByteLength(str) {
Β  Β  return new Blob([str]).size;
Β  }

Β  function formatLength(chars, bytes) {
Β  Β  const charLabel = (chars === 1) ? "character" : "characters";
Β  Β  const byteLabel = (bytes === 1) ? "byte" : "bytes";
Β  Β  return `${chars} ${charLabel}, ${bytes} ${byteLabel}`;
Β  }

Β  function updateLengthFromInput(id, lenId) {
Β  Β  const v = document.getElementById(id).value || "";
Β  Β  document.getElementById(lenId).innerText =
Β  Β  Β  formatLength(v.length, getByteLength(v));
Β  }

Β  function updateLengthFromElementText(id, lenId) {
Β  Β  const v = document.getElementById(id).innerText || "";
Β  Β  document.getElementById(lenId).innerText =
Β  Β  Β  formatLength(v.length, getByteLength(v));
Β  }

Β  function copyInput(id) {
Β  Β  const v = document.getElementById(id).value || "";
Β  Β  if (!v.trim()) { alert("λ³µμ‚¬ν•  λ‚΄μ©μ΄ μ—†μµλ‹λ‹¤."); return; }
Β  Β  navigator.clipboard.writeText(v).then(() => alert("λ³µμ‚¬λμ—μµλ‹λ‹¤."));
Β  }

Β  function copyText(id) {
Β  Β  const v = document.getElementById(id).innerText || "";
Β  Β  if (!v.trim()) { alert("λ³µμ‚¬ν•  λ‚΄μ©μ΄ μ—†μµλ‹λ‹¤."); return; }
Β  Β  // IV μ•λ‚΄ λ¬Έκµ¬ μ κ±°
Β  Β  const cleanV = v.split('\n')[0].trim();
Β  Β  navigator.clipboard.writeText(cleanV).then(() => alert("λ³µμ‚¬λμ—μµλ‹λ‹¤."));
Β  }

Β  function hexToBytes(hex) {
Β  Β  const clean = hex.replace(/\s+/g, "");
Β  Β  if (clean.length % 2 !== 0) throw new Error("invalid hex length");
Β  Β  const arr = new Uint8Array(clean.length / 2);
Β  Β  for (let i = 0; i < clean.length; i += 2) {
Β  Β  Β  const b = parseInt(clean.substr(i, 2), 16);
Β  Β  Β  if (isNaN(b)) throw new Error("invalid hex");
Β  Β  Β  arr[i / 2] = b;
Β  Β  }
Β  Β  return arr;
Β  }

Β  function base64ToBytes(b64) {
Β  Β  const bin = atob(b64);
Β  Β  const arr = new Uint8Array(bin.length);
Β  Β  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
Β  Β  return arr;
Β  }

Β  function bytesToHex(bytes) {
Β  Β  let hex = "";
Β  Β  for (let b of bytes) hex += b.toString(16).padStart(2, "0");
Β  Β  return hex.toUpperCase();
Β  }

Β  function bytesToBase64(bytes) {
Β  Β  let bin = "";
Β  Β  for (let b of bytes) bin += String.fromCharCode(b);
Β  Β  return btoa(bin);
Β  }

Β  function textToBytes(str) {
Β  Β  return new TextEncoder().encode(str);
Β  }

Β  function bytesToText(bytes) {
Β  Β  return new TextDecoder().decode(bytes);
Β  }

Β  /* ============ AES / IV UI ============ */

Β  function updateIvVisibility() {
Β  Β  const mode = document.getElementById("aesBlockMode").value;
Β  Β  const ivMode = document.getElementById("aesIvMode").value;
Β  Β  const ivRow = document.getElementById("ivRow");

Β  Β  // CBC/CTR/GCMλ§ IV ν•„μ”
Β  Β  if (!["cbc", "ctr", "gcm"].includes(mode)) {
Β  Β  Β  ivRow.style.display = "none";
Β  Β  Β  return;
Β  Β  }

Β  Β  // CBC/CTR/GCM + IV λ¨λ“
Β  Β  if (ivMode === "auto") {
Β  Β  Β  ivRow.style.display = "none";
Β  Β  } else {
Β  Β  Β  ivRow.style.display = "flex";
Β  Β  }
Β  }

Β  function onBlockModeChange() {
Β  Β  updateIvVisibility();
Β  }

Β  function onIvModeChange() {
Β  Β  updateIvVisibility();
Β  }

Β  /* ============ PBKDF2 UI ============ */

Β  function onPbkdf2SaltEncodingChange() {
Β  Β  const enc = document.getElementById("pbkdf2SaltEncoding").value;
Β  Β  const row = document.getElementById("pbkdf2SaltRow");
Β  Β  if (enc === "auto") {
Β  Β  Β  row.style.display = "none";
Β  Β  } else {
Β  Β  Β  row.style.display = "flex";
Β  Β  }
Β  }

Β  function initLengths() {
Β  Β  // PBKDF2
Β  Β  updateLengthFromInput("pbkdf2SecretInput", "lenPbkdf2SecretInput");
Β  Β  updateLengthFromInput("pbkdf2SaltInput", "lenPbkdf2SaltInput");
Β  Β  updateLengthFromElementText("pbkdf2Result", "lenPbkdf2Result");

Β  Β  // AES
Β  Β  updateLengthFromInput("aesInput", "lenAesInput");
Β  Β  updateLengthFromInput("aesKeyInput", "lenAesKeyInput");
Β  Β  updateLengthFromInput("aesIvInput", "lenAesIvInput");
Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");

Β  Β  // RSA
Β  Β  updateLengthFromInput("rsaDataInput", "lenRsaDataInput");
Β  Β  updateLengthFromInput("rsaPublicKeyInput", "lenRsaPublicKeyInput");
Β  Β  updateLengthFromInput("rsaPrivateKeyInput", "lenRsaPrivateKeyInput");
Β  Β  updateLengthFromElementText("rsaResult", "lenRsaResult");
Β  }

Β  document.addEventListener("DOMContentLoaded", function () {
Β  Β  onBlockModeChange();
Β  Β  onPbkdf2SaltEncodingChange();
Β  Β  initLengths();
Β  });

Β  /* ============ IV λλ¤ μƒμ„± ============ */
Β  function generateRandomIv(mode) {
Β  Β  let len = 16;Β  Β  Β  Β  Β  // CBC/CTR κΈ°λ³Έ 16λ°”μ΄νΈ
Β  Β  if (mode === "gcm") {Β  // GCMμ€ 12λ°”μ΄νΈ(96bit) κ¶μ¥
Β  Β  Β  len = 12;
Β  Β  }
Β  Β  const iv = new Uint8Array(len);
Β  Β  crypto.getRandomValues(iv);
Β  Β  return iv;
Β  }

Β  /* ============ AES μ•”/λ³µνΈν™” (κΈ°μ΅΄ μ½”λ“) ============ */

Β  async function runAes() {
Β  Β  // ... (κΈ°μ΅΄ AES μ•”/λ³µνΈν™” λ΅μ§ μ μ§€)
Β  Β  const op = document.getElementById("aesOperation").value;
Β  Β  const dataFormat = document.getElementById("aesDataFormat").value;
Β  Β  const keyEnc = document.getElementById("aesKeyEncoding").value;
Β  Β  const keyBits = parseInt(document.getElementById("aesKeySize").value, 10);
Β  Β  const mode = document.getElementById("aesBlockMode").value;
Β  Β  const padding = document.getElementById("aesPadding").value;

Β  Β  const encOutEnc = document.getElementById("aesEncryptEncoding").value;
Β  Β  const decOutFormat = document.getElementById("aesDecryptOutputFormat").value;

Β  Β  const dataStr = document.getElementById("aesInput").value;
Β  Β  const keyStr = document.getElementById("aesKeyInput").value;
Β  Β  const ivStrΒ  = document.getElementById("aesIvInput").value;
Β  Β  const ivMode = document.getElementById("aesIvMode").value;

Β  Β  const resultDiv = document.getElementById("aesResult");

Β  Β  if (!window.crypto || !window.crypto.subtle) {
Β  Β  Β  resultDiv.innerText = "μ΄ λΈλΌμ°μ €μ—μ„λ” Web Crypto API(crypto.subtle)λ¥Ό μ§€μ›ν•μ§€ μ•μµλ‹λ‹¤.";
Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  return;
Β  Β  }

Β  Β  // μ§€μ› λ¨λ“ μ ν•
Β  Β  if (["ecb", "cfb", "ofb"].includes(mode)) {
Β  Β  Β  resultDiv.innerText = "μ„ νƒν• λΈ”λ΅λ¨λ“(" + mode.toUpperCase() +
Β  Β  Β  Β  ")λ” λΈλΌμ°μ € Web Crypto APIμ—μ„ μ§€μ›λμ§€ μ•μµλ‹λ‹¤.";
Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  return;
Β  Β  }

Β  Β  // Padding μ μ•½: Web Cryptoλ” CBCμ—μ„ λ‚΄λ¶€μ μΌλ΅ PKCS#7 ν¨λ”© μ‚¬μ©, μ„ νƒ λ¶κ°€
Β  Β  if (mode === "cbc" && padding !== "pkcs7") {
Β  Β  Β  resultDiv.innerText = "AES-CBCλ” Web Cryptoμ—μ„ PKCS#7 ν¨λ”©λ§ μ§€μ›ν•©λ‹λ‹¤. paddingμ„ pkcs7λ΅ μ„ νƒν•΄ μ£Όμ„Έμ”.";
Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  return;
Β  Β  }
Β  Β  if (["ctr", "gcm"].includes(mode) && padding !== "nopad") {
Β  Β  Β  resultDiv.innerText = "AES-" + mode.toUpperCase() +
Β  Β  Β  Β  " λ¨λ“λ” ν¨λ”© κ°λ…μ΄ μ—†μΌλ―€λ΅ padding = nopad λ΅ μ‚¬μ©ν•λ” κ²ƒμ΄ μ•μ „ν•©λ‹λ‹¤.";
Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  return;
Β  Β  }

Β  Β  if (!dataStr) {
Β  Β  Β  resultDiv.innerText = "λ°μ΄ν„°λ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”.";
Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  return;
Β  Β  }
Β  Β  if (!keyStr) {
Β  Β  Β  resultDiv.innerText = "ν‚¤λ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”.";
Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  return;
Β  Β  }

Β  Β  try {
Β  Β  Β  // 1. ν‚¤ μ²λ¦¬
Β  Β  Β  let keyBytes;
Β  Β  Β  if (keyEnc === "hex") keyBytes = hexToBytes(keyStr);
Β  Β  Β  else keyBytes = base64ToBytes(keyStr);

Β  Β  Β  if (![16, 32].includes(keyBytes.length)) {
Β  Β  Β  Β  resultDiv.innerText =
Β  Β  Β  Β  Β  "ν‚¤ κΈΈμ΄κ°€ μ¬λ°”λ¥΄μ§€ μ•μµλ‹λ‹¤. AES-128μ€ 16λ°”μ΄νΈ, AES-256μ€ 32λ°”μ΄νΈ ν‚¤κ°€ ν•„μ”ν•©λ‹λ‹¤.";
Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  return;
Β  Β  Β  }
Β  Β  Β  if (keyBits === 128 && keyBytes.length !== 16) {
Β  Β  Β  Β  resultDiv.innerText = "μ„ νƒν• ν‚¤ κΈΈμ΄(128bit)μ— λ§κ² 16λ°”μ΄νΈ ν‚¤λ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”.";
Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  return;
Β  Β  Β  }
Β  Β  Β  if (keyBits === 256 && keyBytes.length !== 32) {
Β  Β  Β  Β  resultDiv.innerText = "μ„ νƒν• ν‚¤ κΈΈμ΄(256bit)μ— λ§κ² 32λ°”μ΄νΈ ν‚¤λ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”.";
Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  return;
Β  Β  Β  }

Β  Β  Β  // 2. IV μ²λ¦¬ (CBC / CTR / GCM)
Β  Β  Β  let ivBytes = null;
Β  Β  Β  let ivInfoText = "";
Β  Β  Β  if (["cbc", "ctr", "gcm"].includes(mode)) {
Β  Β  Β  Β  if (ivMode === "auto") {
Β  Β  Β  Β  Β  if (op === "decrypt") {
Β  Β  Β  Β  Β  Β  resultDiv.innerText =
Β  Β  Β  Β  Β  Β  Β  "λ³µνΈν™” μ‹μ—λ” IVλ¥Ό μλ™ μƒμ„±ν•  μ μ—†μµλ‹λ‹¤.\nμ•”νΈν™” μ‹ μ‚¬μ©ν• IVλ¥Ό μλ™μΌλ΅ μ…λ ¥ν•μ„Έμ”.";
Β  Β  Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  Β  Β  return;
Β  Β  Β  Β  Β  }
Β  Β  Β  Β  Β  // μ•”νΈν™” + auto β†’ λλ¤ IV μƒμ„±
Β  Β  Β  Β  Β  ivBytes = generateRandomIv(mode);
Β  Β  Β  Β  Β  const ivLabel = (encOutEnc === "hex") ? "IV HEX" : "IV Base64";
Β  Β  Β  Β  Β  const ivStrOut = (encOutEnc === "hex")
Β  Β  Β  Β  Β  Β  ? bytesToHex(ivBytes)
Β  Β  Β  Β  Β  Β  : bytesToBase64(ivBytes);
Β  Β  Β  Β  Β  ivInfoText = `\n(${ivLabel}: ${ivStrOut})`;
Β  Β  Β  Β  } else {
Β  Β  Β  Β  Β  // μλ™ μ…λ ¥ (hex / base64)
Β  Β  Β  Β  Β  if (!ivStr) {
Β  Β  Β  Β  Β  Β  resultDiv.innerText = "μ„ νƒν• λΈ”λ΅λ¨λ“μ—μ„λ” IVκ°€ ν•„μ”ν•©λ‹λ‹¤.";
Β  Β  Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  Β  Β  return;
Β  Β  Β  Β  Β  }
Β  Β  Β  Β  Β  if (ivMode === "hex") ivBytes = hexToBytes(ivStr);
Β  Β  Β  Β  Β  else ivBytes = base64ToBytes(ivStr);
Β  Β  Β  Β  }
Β  Β  Β  }

Β  Β  Β  // 3. λ°μ΄ν„° μ²λ¦¬
Β  Β  Β  let dataBytes;
Β  Β  Β  if (dataFormat === "plain") {
Β  Β  Β  Β  dataBytes = textToBytes(dataStr);
Β  Β  Β  } else if (dataFormat === "hex") {
Β  Β  Β  Β  dataBytes = hexToBytes(dataStr);
Β  Β  Β  } else { // base64
Β  Β  Β  Β  dataBytes = base64ToBytes(dataStr);
Β  Β  Β  }

Β  Β  Β  // 4. μ•κ³ λ¦¬μ¦ μ΄λ¦„ λ§¤ν•‘
Β  Β  Β  let algoName;
Β  Β  Β  if (mode === "cbc") algoName = "AES-CBC";
Β  Β  Β  else if (mode === "ctr") algoName = "AES-CTR";
Β  Β  Β  else if (mode === "gcm") algoName = "AES-GCM";
Β  Β  Β  else {
Β  Β  Β  Β  resultDiv.innerText = "μ§€μ›λμ§€ μ•λ” λ¨λ“μ…λ‹λ‹¤.";
Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  return;
Β  Β  Β  }

Β  Β  Β  // 5. ν‚¤ import
Β  Β  Β  const key = await crypto.subtle.importKey(
Β  Β  Β  Β  "raw",
Β  Β  Β  Β  keyBytes,
Β  Β  Β  Β  { name: algoName, length: keyBits },
Β  Β  Β  Β  false,
Β  Β  Β  Β  ["encrypt", "decrypt"]
Β  Β  Β  );

Β  Β  Β  // 6. μ•κ³ λ¦¬μ¦ νλΌλ―Έν„°
Β  Β  Β  let algorithm;
Β  Β  Β  if (algoName === "AES-CBC") {
Β  Β  Β  Β  algorithm = { name: "AES-CBC", iv: ivBytes };
Β  Β  Β  } else if (algoName === "AES-CTR") {
Β  Β  Β  Β  algorithm = { name: "AES-CTR", counter: ivBytes, length: 64 };
Β  Β  Β  } else if (algoName === "AES-GCM") {
Β  Β  Β  Β  algorithm = { name: "AES-GCM", iv: ivBytes, tagLength: 128 };
Β  Β  Β  }

Β  Β  Β  // 7. μ•”/λ³µνΈν™” μν–‰
Β  Β  Β  if (op === "encrypt") {
Β  Β  Β  Β  const cipherBuffer = await crypto.subtle.encrypt(algorithm, key, dataBytes);
Β  Β  Β  Β  const cipherBytes = new Uint8Array(cipherBuffer);

Β  Β  Β  Β  const out = (encOutEnc === "hex")
Β  Β  Β  Β  Β  ? bytesToHex(cipherBytes)
Β  Β  Β  Β  Β  : bytesToBase64(cipherBytes);

Β  Β  Β  Β  resultDiv.innerText = out + ivInfoText;
Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  } else {
Β  Β  Β  Β  // decrypt
Β  Β  Β  Β  try {
Β  Β  Β  Β  Β  const plainBuffer = await crypto.subtle.decrypt(algorithm, key, dataBytes);
Β  Β  Β  Β  Β  const plainBytes = new Uint8Array(plainBuffer);

Β  Β  Β  Β  Β  let out;
Β  Β  Β  Β  Β  if (decOutFormat === "plain") {
Β  Β  Β  Β  Β  Β  // UTF-8 λ¬Έμμ—΄λ΅ λ””μ½”λ”© μ‹λ„
Β  Β  Β  Β  Β  Β  try {
Β  Β  Β  Β  Β  Β  Β  out = bytesToText(plainBytes);
Β  Β  Β  Β  Β  Β  } catch {
Β  Β  Β  Β  Β  Β  Β  out = "[UTF-8 λ””μ½”λ”© μ‹¤ν¨] HEX: " + bytesToHex(plainBytes);
Β  Β  Β  Β  Β  Β  }
Β  Β  Β  Β  Β  } else if (decOutFormat === "hex") {
Β  Β  Β  Β  Β  Β  out = bytesToHex(plainBytes);
Β  Β  Β  Β  Β  } else { // base64
Β  Β  Β  Β  Β  Β  out = bytesToBase64(plainBytes);
Β  Β  Β  Β  Β  }

Β  Β  Β  Β  Β  resultDiv.innerText = out;
Β  Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  } catch (e) {
Β  Β  Β  Β  Β  console.error(e);
Β  Β  Β  Β  Β  resultDiv.innerText = "λ³µνΈν™” μ‹¤ν¨ (ν‚¤/IV/λ¨λ“/λ°μ΄ν„°λ¥Ό ν™•μΈν•μ„Έμ”)";
Β  Β  Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  Β  Β  }
Β  Β  Β  }
Β  Β  } catch (e) {
Β  Β  Β  console.error(e);
Β  Β  Β  resultDiv.innerText = "μ²λ¦¬ μ¤‘ μ¤λ¥κ°€ λ°μƒν–μµλ‹λ‹¤. μ…λ ¥κ°’κ³Ό μ„¤μ •μ„ ν™•μΈν•μ„Έμ”.";
Β  Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  Β  }
Β  }

Β  function clearAes() {
Β  Β  // ... (κΈ°μ΅΄ clearAes λ΅μ§ μ μ§€)
Β  Β  document.getElementById("aesInput").value = "";
Β  Β  document.getElementById("aesKeyInput").value = "";
Β  Β  document.getElementById("aesIvInput").value = "";
Β  Β  document.getElementById("aesResult").innerText = "";

Β  Β  document.getElementById("aesOperation").value = "encrypt";
Β  Β  document.getElementById("aesDataFormat").value = "plain";
Β  Β  document.getElementById("aesKeyEncoding").value = "hex";
Β  Β  document.getElementById("aesKeySize").value = "256";
Β  Β  document.getElementById("aesBlockMode").value = "cbc";
Β  Β  document.getElementById("aesPadding").value = "pkcs7";
Β  Β  document.getElementById("aesEncryptEncoding").value = "hex";
Β  Β  document.getElementById("aesDecryptOutputFormat").value = "plain";
Β  Β  document.getElementById("aesIvMode").value = "auto";

Β  Β  updateIvVisibility();
Β  Β  updateLengthFromInput("aesInput", "lenAesInput");
Β  Β  updateLengthFromInput("aesKeyInput", "lenAesKeyInput");
Β  Β  updateLengthFromInput("aesIvInput", "lenAesIvInput");
Β  Β  updateLengthFromElementText("aesResult", "lenAesResult");
Β  }

Β  /* ============ PBKDF2 ν‚¤ μ¤νΈλ μΉ­ (κΈ°μ΅΄ μ½”λ“) ============ */

Β  let pbkdf2LastKey = "";
Β  let pbkdf2LastKeyEncoding = "hex"; // hex or base64

Β  async function runPbkdf2() {
Β  Β  // ... (κΈ°μ΅΄ runPbkdf2 λ΅μ§ μ μ§€)
Β  Β  const secretStr = document.getElementById("pbkdf2SecretInput").value.trim();
Β  Β  const saltStr Β  = document.getElementById("pbkdf2SaltInput").value.trim();
Β  Β  const secretEnc = document.getElementById("pbkdf2SecretEncoding").value;
Β  Β  const saltEnc Β  = document.getElementById("pbkdf2SaltEncoding").value;
Β  Β  const hashAlg Β  = document.getElementById("pbkdf2Hash").value;
Β  Β  const iterΒ  Β  Β  = parseInt(document.getElementById("pbkdf2Iterations").value, 10) || 0;
Β  Β  const keyBits Β  = parseInt(document.getElementById("pbkdf2KeyLength").value, 10);
Β  Β  const outEncΒ  Β  = document.getElementById("pbkdf2OutputEncoding").value;

Β  Β  const resultDiv = document.getElementById("pbkdf2Result");

Β  Β  if (!secretStr) {
Β  Β  Β  alert("secret(λΉ„λ°€λ²νΈ)λ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”.");
Β  Β  Β  return;
Β  Β  }
Β  Β  if (saltEnc !== "auto" && !saltStr) {
Β  Β  Β  alert("salt κ°’μ„ μ…λ ¥ν•΄ μ£Όμ„Έμ”.");
Β  Β  Β  return;
Β  Β  }
Β  Β  if (!iter || iter <= 0) {
Β  Β  Β  alert("iteration νμλ¥Ό 1 μ΄μƒμΌλ΅ μ…λ ¥ν•΄ μ£Όμ„Έμ”.");
Β  Β  Β  return;
Β  Β  }

Β  Β  if (!window.crypto || !window.crypto.subtle) {
Β  Β  Β  resultDiv.innerText =
Β  Β  Β  Β  "μ΄ λΈλΌμ°μ €μ—μ„λ” Web Crypto API(crypto.subtle)λ¥Ό μ§€μ›ν•μ§€ μ•μµλ‹λ‹¤.";
Β  Β  Β  updateLengthFromElementText("pbkdf2Result", "lenPbkdf2Result");
Β  Β  Β  return;
Β  Β  }

Β  Β  try {
Β  Β  Β  let secretBytes;
Β  Β  Β  if (secretEnc === "plain") secretBytes = textToBytes(secretStr);
Β  Β  Β  else if (secretEnc === "hex") secretBytes = hexToBytes(secretStr);
Β  Β  Β  else secretBytes = base64ToBytes(secretStr);

Β  Β  Β  let saltBytes;
Β  Β  Β  if (saltEnc === "auto") {
Β  Β  Β  Β  // 16λ°”μ΄νΈ λλ¤ salt μƒμ„±
Β  Β  Β  Β  saltBytes = new Uint8Array(16);
Β  Β  Β  Β  crypto.getRandomValues(saltBytes);
Β  Β  Β  } else {
Β  Β  Β  Β  if (saltEnc === "plain") saltBytes = textToBytes(saltStr);
Β  Β  Β  Β  else if (saltEnc === "hex") saltBytes = hexToBytes(saltStr);
Β  Β  Β  Β  else saltBytes = base64ToBytes(saltStr);
Β  Β  Β  }

Β  Β  Β  const baseKey = await crypto.subtle.importKey(
Β  Β  Β  Β  "raw",
Β  Β  Β  Β  secretBytes,
Β  Β  Β  Β  { name: "PBKDF2" },
Β  Β  Β  Β  false,
Β  Β  Β  Β  ["deriveBits"]
Β  Β  Β  );

Β  Β  Β  const bits = await crypto.subtle.deriveBits(
Β  Β  Β  Β  {
Β  Β  Β  Β  Β  name: "PBKDF2",
Β  Β  Β  Β  Β  hash: hashAlg,
Β  Β  Β  Β  Β  salt: saltBytes,
Β  Β  Β  Β  Β  iterations: iter
Β  Β  Β  Β  },
Β  Β  Β  Β  baseKey,
Β  Β  Β  Β  keyBits
Β  Β  Β  );

Β  Β  Β  const keyBytes = new Uint8Array(bits);
Β  Β  Β  let keyStr;
Β  Β  Β  if (outEnc === "hex") keyStr = bytesToHex(keyBytes);
Β  Β  Β  else keyStr = bytesToBase64(keyBytes);

Β  Β  Β  pbkdf2LastKey = keyStr;
Β  Β  Β  pbkdf2LastKeyEncoding = outEnc;

Β  Β  Β  const saltHex = bytesToHex(saltBytes);

Β  Β  Β  // κ²°κ³Ό: ν‚¤ + μ‚¬μ©λ salt(HEX) ν‘μ‹
Β  Β  Β  const text = keyStr + "\n(Salt HEX: " + saltHex + ")";
Β  Β  Β  resultDiv.innerText = text;
Β  Β  Β  updateLengthFromElementText("pbkdf2Result", "lenPbkdf2Result");
Β  Β  } catch (e) {
Β  Β  Β  console.error(e);
Β  Β  Β  resultDiv.innerText = "PBKDF2 μ²λ¦¬ μ¤‘ μ¤λ¥κ°€ λ°μƒν–μµλ‹λ‹¤. μ…λ ¥κ°’μ„ ν™•μΈν•μ„Έμ”.";
Β  Β  Β  updateLengthFromElementText("pbkdf2Result", "lenPbkdf2Result");
Β  Β  }
Β  }

Β  function applyPbkdf2KeyToAes() {
Β  Β  // ... (κΈ°μ΅΄ applyPbkdf2KeyToAes λ΅μ§ μ μ§€)
Β  Β  if (!pbkdf2LastKey) {
Β  Β  Β  alert("λ¨Όμ € PBKDF2λ΅ ν‚¤λ¥Ό μƒμ„±ν•΄ μ£Όμ„Έμ”.");
Β  Β  Β  return;
Β  Β  }
Β  Β  document.getElementById("aesKeyEncoding").value =
Β  Β  Β  (pbkdf2LastKeyEncoding === "hex") ? "hex" : "base64";
Β  Β  document.getElementById("aesKeyInput").value = pbkdf2LastKey;
Β  Β  updateLengthFromInput("aesKeyInput", "lenAesKeyInput");
Β  Β  alert("PBKDF2λ΅ μƒμ„±λ ν‚¤λ¥Ό AES ν‚¤ μ…λ ¥μ— μ μ©ν–μµλ‹λ‹¤.");
Β  }

Β  function clearPbkdf2() {
Β  Β  // ... (κΈ°μ΅΄ clearPbkdf2 λ΅μ§ μ μ§€)
Β  Β  document.getElementById("pbkdf2SecretInput").value = "";
Β  Β  document.getElementById("pbkdf2SaltInput").value = "";
Β  Β  document.getElementById("pbkdf2Result").innerText = "";

Β  Β  document.getElementById("pbkdf2SecretEncoding").value = "plain";
Β  Β  document.getElementById("pbkdf2SaltEncoding").value = "auto";
Β  Β  document.getElementById("pbkdf2Hash").value = "SHA-256";
Β  Β  document.getElementById("pbkdf2Iterations").value = "100000";
Β  Β  document.getElementById("pbkdf2KeyLength").value = "256";
Β  Β  document.getElementById("pbkdf2OutputEncoding").value = "hex";

Β  Β  pbkdf2LastKey = "";
Β  Β  pbkdf2LastKeyEncoding = "hex";

Β  Β  onPbkdf2SaltEncodingChange();
Β  Β  updateLengthFromInput("pbkdf2SecretInput", "lenPbkdf2SecretInput");
Β  Β  updateLengthFromInput("pbkdf2SaltInput", "lenPbkdf2SaltInput");
Β  Β  updateLengthFromElementText("pbkdf2Result", "lenPbkdf2Result");
Β  }
Β  
Β  /* ============ RSA ν‚¤ μ λ° μ•”/λ³µνΈν™” (μ¶”κ°€λ κΈ°λ¥) ============ */
Β  
Β  let rsaGeneratedKeyPair = null; // μƒμ„±λ ν‚¤ μ μ €μ¥

Β  // 1. Public Key - Private Key μ μƒμ„±
Β  async function generateRsaKeys() {
Β  Β  if (!window.crypto || !window.crypto.subtle) {
Β  Β  Β  alert("μ΄ λΈλΌμ°μ €μ—μ„λ” Web Crypto API(crypto.subtle)λ¥Ό μ§€μ›ν•μ§€ μ•μµλ‹λ‹¤.");
Β  Β  Β  return;
Β  Β  }

Β  Β  const keySize = parseInt(document.getElementById("rsaKeySize").value, 10);
Β  Β  const hashAlg = document.getElementById("rsaHash").value;
Β  Β  
Β  Β  try {
Β  Β  Β  const keyPair = await crypto.subtle.generateKey(
Β  Β  Β  Β  {
Β  Β  Β  Β  Β  name: "RSA-OAEP",
Β  Β  Β  Β  Β  modulusLength: keySize,
Β  Β  Β  Β  Β  publicExponent: new Uint8Array([0x01, 0x00, 0x01]), // 65537
Β  Β  Β  Β  Β  hash: { name: hashAlg },
Β  Β  Β  Β  },
Β  Β  Β  Β  true, // extractable
Β  Β  Β  Β  ["encrypt", "decrypt"]
Β  Β  Β  );
Β  Β  Β  
Β  Β  Β  rsaGeneratedKeyPair = keyPair;

Β  Β  Β  // ν‚¤ export (SPKI/PKCS8 + Base64)
Β  Β  Β  const pubKeyBuffer = await crypto.subtle.exportKey("spki", keyPair.publicKey);
Β  Β  Β  const privKeyBuffer = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);

Β  Β  Β  const pubKeyBase64 = bytesToBase64(new Uint8Array(pubKeyBuffer));
Β  Β  Β  const privKeyBase64 = bytesToBase64(new Uint8Array(privKeyBuffer));
Β  Β  Β  
Β  Β  Β  document.getElementById("rsaPublicKeyOutput").innerText = pubKeyBase64;
Β  Β  Β  document.getElementById("rsaPrivateKeyOutput").innerText = privKeyBase64;
Β  Β  Β  
Β  Β  Β  updateLengthFromElementText("rsaPublicKeyOutput", "lenRsaPublicKeyOutput");
Β  Β  Β  updateLengthFromElementText("rsaPrivateKeyOutput", "lenRsaPrivateKeyOutput");
Β  Β  Β  
Β  Β  Β  alert(`RSA ${keySize} bit ν‚¤ μμ΄ μƒμ„±λμ—μµλ‹λ‹¤.`);

Β  Β  } catch (e) {
Β  Β  Β  console.error(e);
Β  Β  Β  alert("RSA ν‚¤ μ μƒμ„± μ¤‘ μ¤λ¥κ°€ λ°μƒν–μµλ‹λ‹¤. λΈλΌμ°μ € μ§€μ› μ—¬λ¶€λ¥Ό ν™•μΈν•μ„Έμ”.");
Β  Β  }
Β  }

Β  // 2. RSA μ•”νΈν™”
Β  async function runRsaEncryption() {
Β  Β  const dataStr = document.getElementById("rsaDataInput").value.trim();
Β  Β  const dataFormat = document.getElementById("rsaDataFormat").value; // plain/hex/base64
Β  Β  const keySource = document.getElementById("rsaKeySource").value; // generated / input
Β  Β  const pubKeyStr = document.getElementById("rsaPublicKeyInput").value.trim();
Β  Β  const hashAlg = document.getElementById("rsaHash").value;
Β  Β  const resultDiv = document.getElementById("rsaResult");
Β  Β  
Β  Β  resultDiv.innerText = "";
Β  Β  updateLengthFromElementText("rsaResult", "lenRsaResult");
Β  Β  
Β  Β  if (!dataStr) { resultDiv.innerText = "λ°μ΄ν„°λ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”."; return; }
Β  Β  
Β  Β  try {
Β  Β  Β  // λ°μ΄ν„° μ¤€λΉ„
Β  Β  Β  let dataBytes;
Β  Β  Β  if (dataFormat === "plain") dataBytes = textToBytes(dataStr);
Β  Β  Β  else if (dataFormat === "hex") dataBytes = hexToBytes(dataStr);
Β  Β  Β  else dataBytes = base64ToBytes(dataStr);

Β  Β  Β  // μ•”νΈν™” ν‚¤ κ°€μ Έμ¤κΈ°
Β  Β  Β  let publicKey;
Β  Β  Β  
Β  Β  Β  if (keySource === "generated") {
Β  Β  Β  Β  if (!rsaGeneratedKeyPair) {
Β  Β  Β  Β  Β  resultDiv.innerText = "ν‚¤ μμ„ λ¨Όμ € μƒμ„±ν•΄ μ£Όμ„Έμ”."; return;
Β  Β  Β  Β  }
Β  Β  Β  Β  publicKey = rsaGeneratedKeyPair.publicKey;
Β  Β  Β  } else {
Β  Β  Β  Β  if (!pubKeyStr) {
Β  Β  Β  Β  Β  resultDiv.innerText = "Public Keyλ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”."; return;
Β  Β  Β  Β  }
Β  Β  Β  Β  const keyBytes = base64ToBytes(pubKeyStr);
Β  Β  Β  Β  publicKey = await crypto.subtle.importKey(
Β  Β  Β  Β  Β  "spki",
Β  Β  Β  Β  Β  keyBytes,
Β  Β  Β  Β  Β  { name: "RSA-OAEP", hash: { name: hashAlg } },
Β  Β  Β  Β  Β  false,
Β  Β  Β  Β  Β  ["encrypt"]
Β  Β  Β  Β  );
Β  Β  Β  }
Β  Β  Β  
Β  Β  Β  // μ•”νΈν™” μν–‰
Β  Β  Β  const cipherBuffer = await crypto.subtle.encrypt(
Β  Β  Β  Β  { name: "RSA-OAEP" },
Β  Β  Β  Β  publicKey,
Β  Β  Β  Β  dataBytes
Β  Β  Β  );
Β  Β  Β  
Β  Β  Β  const cipherBytes = new Uint8Array(cipherBuffer);
Β  Β  Β  const output = bytesToBase64(cipherBytes); // RSA κ²°κ³Όλ” Base64λ΅ ν†µμΌ

Β  Β  Β  resultDiv.innerText = output;
Β  Β  Β  updateLengthFromElementText("rsaResult", "lenRsaResult");

Β  Β  } catch (e) {
Β  Β  Β  console.error(e);
Β  Β  Β  resultDiv.innerText = "RSA μ•”νΈν™” μ‹¤ν¨. λ°μ΄ν„° ν¬κΈ°, Public Key, ν•΄μ‹ μ•κ³ λ¦¬μ¦ λ“±μ„ ν™•μΈν•μ„Έμ”.";
Β  Β  Β  updateLengthFromElementText("rsaResult", "lenRsaResult");
Β  Β  }
Β  }

Β  // 3. RSA λ³µνΈν™”
Β  async function runRsaDecryption() {
Β  Β  const dataStr = document.getElementById("rsaDataInput").value.trim();
Β  Β  const keySource = document.getElementById("rsaKeySource").value; // generated / input
Β  Β  const privKeyStr = document.getElementById("rsaPrivateKeyInput").value.trim();
Β  Β  const decOutFormat = document.getElementById("rsaDecryptOutputFormat").value; // plain/hex/base64
Β  Β  const hashAlg = document.getElementById("rsaHash").value;
Β  Β  const resultDiv = document.getElementById("rsaResult");
Β  Β  
Β  Β  resultDiv.innerText = "";
Β  Β  updateLengthFromElementText("rsaResult", "lenRsaResult");
Β  Β  
Β  Β  if (!dataStr) { resultDiv.innerText = "μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”."; return; }

Β  Β  try {
Β  Β  Β  // λ°μ΄ν„° μ¤€λΉ„ (μ•”νΈν™” κ²°κ³Όλ” Base64λ΅ κ°€μ •)
Β  Β  Β  const dataBytes = base64ToBytes(dataStr);

Β  Β  Β  // λ³µνΈν™” ν‚¤ κ°€μ Έμ¤κΈ°
Β  Β  Β  let privateKey;
Β  Β  Β  
Β  Β  Β  if (keySource === "generated") {
Β  Β  Β  Β  if (!rsaGeneratedKeyPair) {
Β  Β  Β  Β  Β  resultDiv.innerText = "ν‚¤ μμ„ λ¨Όμ € μƒμ„±ν•΄ μ£Όμ„Έμ”."; return;
Β  Β  Β  Β  }
Β  Β  Β  Β  privateKey = rsaGeneratedKeyPair.privateKey;
Β  Β  Β  } else {
Β  Β  Β  Β  if (!privKeyStr) {
Β  Β  Β  Β  Β  resultDiv.innerText = "Private Keyλ¥Ό μ…λ ¥ν•΄ μ£Όμ„Έμ”."; return;
Β  Β  Β  Β  }
Β  Β  Β  Β  const keyBytes = base64ToBytes(privKeyStr);
Β  Β  Β  Β  privateKey = await crypto.subtle.importKey(
Β  Β  Β  Β  Β  "pkcs8",
Β  Β  Β  Β  Β  keyBytes,
Β  Β  Β  Β  Β  { name: "RSA-OAEP", hash: { name: hashAlg } },
Β  Β  Β  Β  Β  false,
Β  Β  Β  Β  Β  ["decrypt"]
Β  Β  Β  Β  );
Β  Β  Β  }

Β  Β  Β  // λ³µνΈν™” μν–‰
Β  Β  Β  const plainBuffer = await crypto.subtle.decrypt(
Β  Β  Β  Β  { name: "RSA-OAEP" },
Β  Β  Β  Β  privateKey,
Β  Β  Β  Β  dataBytes
Β  Β  Β  );
Β  Β  Β  
Β  Β  Β  const plainBytes = new Uint8Array(plainBuffer);
Β  Β  Β  
Β  Β  Β  let output;
Β  Β  Β  if (decOutFormat === "plain") {
Β  Β  Β  Β  try {
Β  Β  Β  Β  Β  output = bytesToText(plainBytes);
Β  Β  Β  Β  } catch {
Β  Β  Β  Β  Β  output = "[UTF-8 λ””μ½”λ”© μ‹¤ν¨] HEX: " + bytesToHex(plainBytes);
Β  Β  Β  Β  }
Β  Β  Β  } else if (decOutFormat === "hex") {
Β  Β  Β  Β  output = bytesToHex(plainBytes);
Β  Β  Β  } else { // base64
Β  Β  Β  Β  output = bytesToBase64(plainBytes);
Β  Β  Β  }

Β  Β  Β  resultDiv.innerText = output;
Β  Β  Β  updateLengthFromElementText("rsaResult", "lenRsaResult");

Β  Β  } catch (e) {
Β  Β  Β  console.error(e);
Β  Β  Β  resultDiv.innerText = "RSA λ³µνΈν™” μ‹¤ν¨. Private Key, ν•΄μ‹ μ•κ³ λ¦¬μ¦, μ•”νΈν™”λ λ°μ΄ν„° ν•μ‹ λ“±μ„ ν™•μΈν•μ„Έμ”.";
Β  Β  Β  updateLengthFromElementText("rsaResult", "lenRsaResult");
Β  Β  }
Β  }

Β  function clearRsa() {
Β  Β  document.getElementById("rsaDataInput").value = "";
Β  Β  document.getElementById("rsaPublicKeyInput").value = "";
Β  Β  document.getElementById("rsaPrivateKeyInput").value = "";
Β  Β  document.getElementById("rsaPublicKeyOutput").innerText = "";
Β  Β  document.getElementById("rsaPrivateKeyOutput").innerText = "";
Β  Β  document.getElementById("rsaResult").innerText = "";

Β  Β  document.getElementById("rsaOperation").value = "encrypt";
Β  Β  document.getElementById("rsaDataFormat").value = "plain";
Β  Β  document.getElementById("rsaKeySize").value = "2048";
Β  Β  document.getElementById("rsaHash").value = "SHA-256";
Β  Β  document.getElementById("rsaKeySource").value = "generated";
Β  Β  document.getElementById("rsaDecryptOutputFormat").value = "plain";
Β  Β  
Β  Β  rsaGeneratedKeyPair = null;
Β  Β  
Β  Β  initLengths();
Β  }
Β  
Β  function onRsaOperationChange() {
Β  Β  const op = document.getElementById("rsaOperation").value;
Β  Β  const decryptFormatRow = document.getElementById("rsaDecryptOutputRow");
Β  Β  const dataFormatSelect = document.getElementById("rsaDataFormat");
Β  Β  
Β  Β  if (op === "encrypt") {
Β  Β  Β  decryptFormatRow.style.display = "none";
Β  Β  Β  document.getElementById("rsaDataFormatLabel").innerText = "λ°μ΄ν„° ν•μ‹:";
Β  Β  Β  if (dataFormatSelect.value === "base64") dataFormatSelect.value = "plain";
Β  Β  Β  dataFormatSelect.querySelectorAll('option[value="base64"]').forEach(opt => opt.hidden = true);
Β  Β  Β  dataFormatSelect.querySelectorAll('option[value="plain"]').forEach(opt => opt.hidden = false);
Β  Β  Β  
Β  Β  } else { // decrypt
Β  Β  Β  decryptFormatRow.style.display = "flex";
Β  Β  Β  document.getElementById("rsaDataFormatLabel").innerText = "μ•”νΈλ¬Έ ν•μ‹:";
Β  Β  Β  dataFormatSelect.value = "base64";
Β  Β  Β  dataFormatSelect.querySelectorAll('option[value="base64"]').forEach(opt => opt.hidden = false);
Β  Β  Β  dataFormatSelect.querySelectorAll('option[value="plain"]').forEach(opt => opt.hidden = true);
Β  Β  Β  
Β  Β  }
Β  Β  document.getElementById("rsaDataInput").placeholder = (op === "encrypt") 
Β  Β  Β  ? "μ•”νΈν™”ν•  ν‰λ¬Έ/λ°μ΄ν„°" 
Β  Β  Β  : "λ³µνΈν™”ν•  μ•”νΈλ¬Έ (Base64)";
Β  }
Β  
Β  document.addEventListener("DOMContentLoaded", function () {
Β  Β  onBlockModeChange();
Β  Β  onPbkdf2SaltEncodingChange();
Β  Β  onRsaOperationChange(); // RSA μ΄κΈ°ν™”
Β  Β  initLengths();
Β  });
Β  
Β  function runRsa() {
Β  Β  const op = document.getElementById("rsaOperation").value;
Β  Β  if (op === "encrypt") {
Β  Β  Β  runRsaEncryption();
Β  Β  } else {
Β  Β  Β  runRsaDecryption();
Β  Β  }
Β  }
</script>

<h2>PBKDF2 ν‚¤ μ¤νΈλ μΉ­</h2>
<div class="option-row">
Β  <span>secret μΈμ½”λ”©:</span>
Β  <select id="pbkdf2SecretEncoding">
Β  Β  <option value="plain" selected>ν‰λ¬Έ</option>
Β  Β  <option value="hex">HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>

Β  <span>salt μΈμ½”λ”©:</span>
Β  <select id="pbkdf2SaltEncoding" onchange="onPbkdf2SaltEncodingChange()">
Β  Β  <option value="auto" selected>μλ™(λλ¤ μƒμ„±)</option>
Β  Β  <option value="plain">ν‰λ¬Έ</option>
Β  Β  <option value="hex">HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>

Β  <span>Hash:</span>
Β  <select id="pbkdf2Hash">
Β  Β  <option value="SHA-256" selected>SHA-256</option>
Β  Β  <option value="SHA-512">SHA-512</option>
Β  </select>
</div>

<div class="row">
Β  <span>secret:</span>
Β  <input id="pbkdf2SecretInput" type="text"
Β Β  Β  Β  Β  placeholder="λΉ„λ°€λ²νΈ / μ‹ν¬λ¦Ώ κ°’"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('pbkdf2SecretInput','lenPbkdf2SecretInput')">
Β  <div id="lenPbkdf2SecretInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('pbkdf2SecretInput')">λ³µμ‚¬</button>
</div>

<div id="pbkdf2SaltRow" class="row">
Β  <span>salt:</span>
Β  <input id="pbkdf2SaltInput" type="text"
Β Β  Β  Β  Β  placeholder="salt κ°’ (autoκ°€ μ•„λ‹ κ²½μ° μ§μ ‘ μ…λ ¥)"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('pbkdf2SaltInput','lenPbkdf2SaltInput')">
Β  <div id="lenPbkdf2SaltInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('pbkdf2SaltInput')">λ³µμ‚¬</button>
</div>

<div class="option-row">
Β  <span>iterations:</span>
Β  <input id="pbkdf2Iterations" type="number" min="1" value="100000" style="width: 120px;">

Β  <span>ν‚¤ κΈΈμ΄:</span>
Β  <select id="pbkdf2KeyLength">
Β  Β  <option value="128">128 bit</option>
Β  Β  <option value="256" selected>256 bit</option>
Β  </select>

Β  <span>μ¶λ ¥ μΈμ½”λ”©:</span>
Β  <select id="pbkdf2OutputEncoding">
Β  Β  <option value="hex" selected>HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>
</div>

<div class="row">
Β  <button onclick="runPbkdf2()">PBKDF2 ν‚¤ μƒμ„±</button>
Β  <button onclick="applyPbkdf2KeyToAes()">μƒμ„±λ ν‚¤ β†’ AES ν‚¤ μ μ©</button>
Β  <button onclick="clearPbkdf2()">μ΄κΈ°ν™”</button>
</div>

<div>
Β  <strong>PBKDF2 κ²°κ³Ό ν‚¤:</strong>
Β  <div class="result-row">
Β  Β  <div id="pbkdf2Result" class="result-box"></div>
Β  Β  <div id="lenPbkdf2Result" class="len-box"></div>
Β  Β  <button class="copy-btn" onclick="copyText('pbkdf2Result')">λ³µμ‚¬</button>
Β  </div>
</div>

<small class="note">
Β  β€» PBKDF2 κ²°κ³Όλ” μ²« μ¤„μ— νμƒ ν‚¤, κ΄„νΈ μ•μ— μ‚¬μ©λ Salt(HEX)λ¥Ό ν•¨κ» ν‘μ‹ν•©λ‹λ‹¤.<br>
Β  β€» "μƒμ„±λ ν‚¤ β†’ AES ν‚¤ μ μ©"μ„ ν΄λ¦­ν•λ©΄ μ•„λ AES ν‚¤ μ…λ ¥ μΉΈμ— μλ™μΌλ΅ μ±„μ›μ§‘λ‹λ‹¤.
</small>

<hr>

<h2>AES μ•”νΈν™”/λ³µνΈν™”</h2>
<div class="option-row">
Β  <span>1. λ™μ‘:</span>
Β  <select id="aesOperation">
Β  Β  <option value="encrypt">μ•”νΈν™”</option>
Β  Β  <option value="decrypt">λ³µνΈν™”</option>
Β  </select>

Β  <span>2. λ°μ΄ν„° ν•μ‹:</span>
Β  <select id="aesDataFormat">
Β  Β  <option value="plain">ν‰λ¬Έ(UTF-8)</option>
Β  Β  <option value="hex">HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>
</div>

<div class="row">
Β  <span>λ°μ΄ν„°:</span>
Β  <input id="aesInput" type="text"
Β Β  Β  Β  Β  placeholder="μ•”νΈν™”/λ³µνΈν™” λ€μƒ λ°μ΄ν„°"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('aesInput','lenAesInput')">
Β  <div id="lenAesInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('aesInput')">λ³µμ‚¬</button>
</div>

<hr>

<div class="option-row">
Β  <span>3. ν‚¤ μΈμ½”λ”©:</span>
Β  <select id="aesKeyEncoding">
Β  Β  <option value="hex">HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>

Β  <span>4. ν‚¤ κΈΈμ΄:</span>
Β  <select id="aesKeySize">
Β  Β  <option value="128">128 bit</option>
Β  Β  <option value="256" selected>256 bit</option>
Β  </select>
</div>

<div class="row">
Β  <span>ν‚¤:</span>
Β  <input id="aesKeyInput" type="text"
Β Β  Β  Β  Β  placeholder="ν‚¤λ¥Ό μ„ νƒν• μΈμ½”λ”© ν•μ‹μΌλ΅ μ…λ ¥ (λλ” μ„ PBKDF2 κ²°κ³Ό μ μ©)"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('aesKeyInput','lenAesKeyInput')">
Β  <div id="lenAesKeyInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('aesKeyInput')">λ³µμ‚¬</button>
</div>

<hr>

<div class="option-row">
Β  <span>5. λΈ”λ΅ λ¨λ“:</span>
Β  <select id="aesBlockMode" onchange="onBlockModeChange()">
Β  Β  <option value="ecb">ECB (λ―Έμ§€μ›)</option>
Β  Β  <option value="cbc" selected>CBC</option>
Β  Β  <option value="cfb">CFB (λ―Έμ§€μ›)</option>
Β  Β  <option value="ofb">OFB (λ―Έμ§€μ›)</option>
Β  Β  <option value="ctr">CTR</option>
Β  Β  <option value="gcm">GCM</option>
Β  </select>

Β  <span>6. Padding:</span>
Β  <select id="aesPadding">
Β  Β  <option value="nopad">NoPadding</option>
Β  Β  <option value="pkcs5">PKCS5</option>
Β  Β  <option value="pkcs7" selected>PKCS7</option>
Β  </select>
</div>

<div class="option-row">
Β  <span>IV λ¨λ“:</span>
Β  <select id="aesIvMode" onchange="onIvModeChange()">
Β  Β  <option value="auto" selected>μλ™ μƒμ„± (μ•”νΈν™” μ‹)</option>
Β  Β  <option value="hex">μλ™ μ…λ ¥ (HEX)</option>
Β  Β  <option value="base64">μλ™ μ…λ ¥ (Base64)</option>
Β  </select>
</div>

<div id="ivRow" class="row">
Β  <span>IV:</span>
Β  <input id="aesIvInput" type="text"
Β Β  Β  Β  Β  placeholder="IVλ¥Ό μ„ νƒν• ν•μ‹μΌλ΅ μ…λ ¥"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('aesIvInput','lenAesIvInput')">
Β  <div id="lenAesIvInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('aesIvInput')">λ³µμ‚¬</button>
</div>

<div class="option-row">
Β  <span>7-1. μ•”νΈν™” κ²°κ³Ό μΈμ½”λ”©:</span>
Β  <select id="aesEncryptEncoding">
Β  Β  <option value="hex" selected>HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>

Β  <span>7-2. λ³µνΈν™” κ²°κ³Ό ν•μ‹:</span>
Β  <select id="aesDecryptOutputFormat">
Β  Β  <option value="plain" selected>ν‰λ¬Έ(UTF-8)</option>
Β  Β  <option value="hex">HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>
</div>

<small class="note">
Β  β€» CBC/CTR/GCMμ—μ„ IVλ” μΌλ°μ μΌλ΅ 16λ°”μ΄νΈ(λλ” GCMμ κ²½μ° 12λ°”μ΄νΈ)λ¥Ό κ¶μ¥ν•©λ‹λ‹¤.<br>
Β  β€» IV λ¨λ“κ°€ "μλ™ μƒμ„±"μΌ λ•λ” μ•”νΈν™” μ‹μ—λ§ λλ¤ IVλ¥Ό λ§λ“¤κ³ , κ²°κ³Όμ— ν•¨κ» ν‘μ‹ν•©λ‹λ‹¤.<br>
Β  β€» λ³µνΈν™” μ‹μ—λ” μ•”νΈν™”μ— μ‚¬μ©λ IVλ¥Ό λ™μΌν•κ² μλ™ μ…λ ¥ν•΄μ•Ό ν•©λ‹λ‹¤.
</small>

<div class="row" style="margin-top: 12px;">
Β  <button onclick="runAes()">μ‹¤ν–‰</button>
Β  <button onclick="clearAes()">μ΄κΈ°ν™”</button>
</div>

<div>
Β  <strong>AES κ²°κ³Ό:</strong>
Β  <div class="result-row">
Β  Β  <div id="aesResult" class="result-box"></div>
Β  Β  <div id="lenAesResult" class="len-box"></div>
Β  Β  <button class="copy-btn" onclick="copyText('aesResult')">λ³µμ‚¬</button>
Β  </div>
</div>

<hr>

<h2>RSA κ³µκ°ν‚¤/κ°μΈν‚¤ (RSA-OAEP)</h2>

<div class="option-row">
Β  <span>ν‚¤ κΈΈμ΄:</span>
Β  <select id="rsaKeySize">
Β  Β  <option value="2048" selected>2048 bit</option>
Β  Β  <option value="4096">4096 bit</option>
Β  </select>

Β  <span>Hash (OAEP):</span>
Β  <select id="rsaHash">
Β  Β  <option value="SHA-256" selected>SHA-256</option>
Β  Β  <option value="SHA-512">SHA-512</option>
Β  </select>
Β  <button onclick="generateRsaKeys()">π”‘ RSA ν‚¤ μ μƒμ„±</button>
Β  <button onclick="clearRsa()">μ΄κΈ°ν™”</button>
</div>

<div>
Β  <strong>Public Key (SPKI, Base64):</strong>
Β  <div class="result-row">
Β  Β  <div id="rsaPublicKeyOutput" class="result-box key-output"></div>
Β  Β  <div id="lenRsaPublicKeyOutput" class="len-box"></div>
Β  Β  <button class="copy-btn" onclick="copyText('rsaPublicKeyOutput')">λ³µμ‚¬</button>
Β  </div>
</div>

<div>
Β  <strong>Private Key (PKCS#8, Base64):</strong>
Β  <div class="result-row">
Β  Β  <div id="rsaPrivateKeyOutput" class="result-box key-output"></div>
Β  Β  <div id="lenRsaPrivateKeyOutput" class="len-box"></div>
Β  Β  <button class="copy-btn" onclick="copyText('rsaPrivateKeyOutput')">λ³µμ‚¬</button>
Β  </div>
</div>

<hr>

<div class="option-row">
Β  <span>1. λ™μ‘:</span>
Β  <select id="rsaOperation" onchange="onRsaOperationChange()">
Β  Β  <option value="encrypt">μ•”νΈν™”</option>
Β  Β  <option value="decrypt">λ³µνΈν™”</option>
Β  </select>

Β  <span id="rsaDataFormatLabel">2. λ°μ΄ν„° ν•μ‹:</span>
Β  <select id="rsaDataFormat">
Β  Β  <option value="plain" selected>ν‰λ¬Έ(UTF-8)</option>
Β  Β  <option value="hex">HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>
</div>

<div id="rsaDecryptOutputRow" class="option-row" style="display: none;">
Β  <span>λ³µνΈν™” κ²°κ³Ό ν•μ‹:</span>
Β  <select id="rsaDecryptOutputFormat">
Β  Β  <option value="plain" selected>ν‰λ¬Έ(UTF-8)</option>
Β  Β  <option value="hex">HEX</option>
Β  Β  <option value="base64">Base64</option>
Β  </select>
</div>

<div class="row">
Β  <span>λ°μ΄ν„°:</span>
Β  <input id="rsaDataInput" type="text"
Β Β  Β  Β  Β  placeholder="μ•”νΈν™”/λ³µνΈν™” λ€μƒ λ°μ΄ν„°"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('rsaDataInput','lenRsaDataInput')">
Β  <div id="lenRsaDataInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('rsaDataInput')">λ³µμ‚¬</button>
</div>

<div class="option-row">
Β  <span>3. ν‚¤ μ‚¬μ©:</span>
Β  <select id="rsaKeySource">
Β  Β  <option value="generated" selected>μ„μ—μ„ μƒμ„±λ ν‚¤ μ‚¬μ©</option>
Β  Β  <option value="input">μλ™ μ…λ ¥ ν‚¤ μ‚¬μ©</option>
Β  </select>
</div>

<div class="row">
Β  <span>Public Key:</span>
Β  <input id="rsaPublicKeyInput" type="text"
Β Β  Β  Β  Β  placeholder="Public Key (Base64, μλ™ μ…λ ¥ μ‹)"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('rsaPublicKeyInput','lenRsaPublicKeyInput')">
Β  <div id="lenRsaPublicKeyInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('rsaPublicKeyInput')">λ³µμ‚¬</button>
</div>

<div class="row">
Β  <span>Private Key:</span>
Β  <input id="rsaPrivateKeyInput" type="text"
Β Β  Β  Β  Β  placeholder="Private Key (Base64, μλ™ μ…λ ¥ μ‹)"
Β Β  Β  Β  Β  oninput="updateLengthFromInput('rsaPrivateKeyInput','lenRsaPrivateKeyInput')">
Β  <div id="lenRsaPrivateKeyInput" class="len-box"></div>
Β  <button class="copy-btn" onclick="copyInput('rsaPrivateKeyInput')">λ³µμ‚¬</button>
</div>

<small class="note">
Β  β€» μ•”νΈν™”: Public Key μ‚¬μ©. κ²°κ³Όλ” Base64 μ•”νΈλ¬Έμ…λ‹λ‹¤.<br>
Β  β€» λ³µνΈν™”: Private Key μ‚¬μ©. λ°μ΄ν„° μ…λ ¥ ν•μ‹μ€ Base64λ΅ μ„¤μ •λ©λ‹λ‹¤.<br>
Β  β€» RSA-OAEPλ” ν‚¤ κΈΈμ΄μ— λ”°λΌ μ•”νΈν™”ν•  μ μλ” **λ°μ΄ν„° ν¬κΈ°μ— μ ν•**μ΄ μμµλ‹λ‹¤.
</small>

<div class="row" style="margin-top: 12px;">
Β  <button onclick="runRsa()">μ‹¤ν–‰</button>
</div>

<div>
Β  <strong>RSA κ²°κ³Ό:</strong>
Β  <div class="result-row">
Β  Β  <div id="rsaResult" class="result-box"></div>
Β  Β  <div id="lenRsaResult" class="len-box"></div>
Β  Β  <button class="copy-btn" onclick="copyText('rsaResult')">λ³µμ‚¬</button>
Β  </div>
</div>

</body>
</html>